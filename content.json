{"meta":{"title":"Modraed Lau's blog","subtitle":null,"description":null,"author":"Modraed Lau","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-03-05T05:33:24.000Z","updated":"2019-03-05T05:33:36.796Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-05T05:34:15.000Z","updated":"2019-03-05T05:34:33.886Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ArrayList的迭代删除","slug":"ArrayList的迭代删除","date":"2019-01-10T09:27:46.000Z","updated":"2019-01-10T10:09:58.620Z","comments":true,"path":"2019/01/10/ArrayList的迭代删除/","link":"","permalink":"http://yoursite.com/2019/01/10/ArrayList的迭代删除/","excerpt":"","text":"引子今天遇到一个问题，就是在使用ArrayList迭代删除出现问题，算是很常见的问题，我知道怎么写是正确的，但是一直不知道为什么会这样，今天我就把这个问题稍微研究深入一点，甚至从JDK的设计思路来想下为什么要这么设计。先从问题开始，示例代码：123456789101112public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) &#123; // it.remove(); // IllegalStateException list.remove(it.next()); // ConcurrentModificationException &#125;&#125; 貌似在迭代中，怎么删除都异常，使用使用迭代器删除抛出IllegalStateException，list本身删除抛出ConcurrentModificationException。使用迭代器删除为什么会出现IllegalStateException呢，我们来看下在ArrayList实现的迭代器源码remove方法开始部分：12if (lastRet &lt; 0) throw new IllegalStateException(); 原来是指向不正确，明眼人马上就看出来了正确删除写法：12345Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; it.next(); it.remove(); // OK&#125; 那么直接使用list删除就必然出现ConcurrentModificationException吗，其实不然，下面展示一些：12345Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; list.remove(\"a\"); // OK break;&#125; 那为什么list.remove(it.next());就会出现异常呢，为什么会这样？还是要到ArrayList的源码中去看，ArrayList的迭代器next方法在最开始的时候都会checkForComodification：12public E next() &#123; checkForComodification(); 那我们继续跟进行checkForComodification方法：1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 再根据上下文我们知道这个modCount表示的实际修改的次数，而expectedModCount表示预计修改的次数，如果不相等就会发生ConcurrentModificationException。 这会我们来debug下，添加三个元素后迭代开始时，debug可以的代：modCount = 3, expectedModCount = 3；接下来我们使用list.remove一次，再进入这里可以发现：modCount = 4, expectedModCount = 3；这说明多了一次修改！然后迭代器在next方法内checkForComodification时抛出ConcurrentModificationException。 那为什么it.remove又是正常的，我们再跟入ArrayList的迭代器实现中的remove方法：1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; // 注意这里 &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 是不是会突然恍然大悟，迭代器中的实现将expectedModCount = modCount又给变成最新的修改值了，而下一次的next方法就会正常执行。 思考使用modCount的作用主要是为了判断发生不正常的修改，而使用list.remove()就会发生，因为在多处会发生修改，不单只会在迭代时还可以在其他任意地方，甚至在多线程环境下造成混乱，而抛出此异常也是给开发人员警告。而JDK的设计人员想引导开发人员使用迭代器remove()，我想主要是使用时只会在迭代元素时，而且迭代器本身有状态判断，基本不会造成其他问题，所以像迭代器remove()操作基本可用。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"http://yoursite.com/categories/Java并发编程/"}],"tags":[{"name":"ArrayList ConcurrentModificationException","slug":"ArrayList-ConcurrentModificationException","permalink":"http://yoursite.com/tags/ArrayList-ConcurrentModificationException/"}]},{"title":"深入理解Java监视器（Monitor）","slug":"深入理解Java监视器（Monitor）","date":"2019-01-05T02:21:25.000Z","updated":"2019-03-05T05:35:58.552Z","comments":true,"path":"2019/01/05/深入理解Java监视器（Monitor）/","link":"","permalink":"http://yoursite.com/2019/01/05/深入理解Java监视器（Monitor）/","excerpt":"","text":"管程我们知道Java中的重量锁是由监视器来实现的，那什么是监视器，监视器又称管程，我们先来看下维基百科上对“管程”的描述： 管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬体装置或一群变数。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。 Mark Word有关MarkWord这部分我们也可以打开hotspot源码可以看到markOop.hpp上相关注释，我把注释进行了翻译并摘抄出重点：1234567891011//// [JavaThread* | epoch | age | 1 | 01] lock is biased toward given thread// [0 | epoch | age | 1 | 01] lock is anonymously biased//// - the two lock bits are used to describe three states: locked/unlocked and monitor.//// [ptr | 00] locked ptr points to real header on stack// [header | 0 | 01] unlocked regular object header// [ptr | 10] monitor inflated lock (header is wapped out)// [ptr | 11] marked used by markSweep to mark an object// not valid at any other time 这里我们值得注意的是在锁膨胀为重量锁时，Mark Word锁标志会变成10，而其他部分将会出现指向对应monitor的指针。 ObjectMonitor另一方面我们从markOop.hpp可以知道其monitor指的就是一个ObjectMonitor，跟踪这点后我们再打开objectMonitor.hpp看下其数据结构：123456789101112131415161718192021// initialize the monitor, exception the semaphore, all other fields// are simple integers or pointersObjectMonitor() &#123; _header = NULL; _count = 0; _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; _previous_owner_tid = 0;&#125; 通过查阅一些资料我们知道这里面有几个重要的信息： _owner：指向持有ObjectMonitor对象的线程。 _cxq：FILO竞争队列，应对多线程竞争锁的时候，使用CAS操作替换队列头部。 _EntryList： cxq中的合适线程可以被放入EntryList，WaitSet中的线程被notify/notifyAll之后，也可能会放入EntryList中，准备竞争锁。 _WaitSet：线程被wait()后，将会被放入WaitSet中。放入WaitSet中的线程被notify/notifyAll后，将会进入cxq或EntryList中。 画了一张图来理解下： 然后我们可以看下objectMonitor.cpp的核心内容，还好这份源码中也提供了一些注释，我们可以从注释出发，了解其中思路。我把注释进行了翻译和整理： 线程成功获取监视器所有权后，使用CAS操作将_owner字段从null更改为非null。 原则：任何时候一个线程最多出现在一个监视器列表——cxq、EntryList或WaitSet上。 竞争线程使用CAS将自己“推”到cxq上，然后自旋/暂停。 竞争线程获得锁后必须从EntryList或cxq中出队。 退出监视器的线程会在EntryList上选择一个“假定继承人“标识并取消暂停。注意：退出的线程不会将后继线程与EntryList断开连接。在取消暂停后，被唤醒者将会重新获取监视器所有权。继任者（被唤醒者）将会获得锁定或者重新暂停。 继承由竞争性切换策略来决定。退出线程不会将所有权直接授予或者传递给后继线程（这个也称为“切换式”继承）。相反，退出线程释放所有权并可能唤醒后继者，后继者可以（重新）争夺锁的所有权。如果EntryList为空但是cxq不为空，退出线程会将cxq中的元素排入EntryList。他通过分离cxq（通过CAS安装null）并将线程从cxq折叠到EntryList中来实现。EntryList为双向链表，而cxq为单向链表，因为最近到达的线程（RATs）需要基于CAS的操作“推”入队列。 并发原则： 只有监视器所有者可以访问或改变EntryList，监视器本身的互斥锁属性可以保护EntryList免受并发干扰。 只有监视器所有者可以分离cxq。 监视器的entry list操作可以避免锁，但严格来说他们不是无锁的。进入是无锁的，退出不是。 cxq可以有多个并发“推送者”但只有一个并发分离线程。这种机制不受ABA问题的影响。更确切地说，基于CAS的“推”到cxq上是不受ABA问题影响的。 总之，cxq和EntryList构成线程的单个逻辑队列，试图获取锁。使用两个不同的列表在acquisition之后提高在一定时间内的出队操作几率，并减少列表末端的热度。一个关键的需求是最小化在保持监视器锁时的发生的队列和监视器元数据操作，即使少量的自旋也会大大减少EntryList/cxq上的入队出队操作的数量。也就是说，自旋减轻了对“内部”锁的争用并监视元数据。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"http://yoursite.com/categories/Java并发编程/"}],"tags":[{"name":"Monitor 并发 锁","slug":"Monitor-并发-锁","permalink":"http://yoursite.com/tags/Monitor-并发-锁/"}]},{"title":"JVM JIT编译器概述","slug":"JVM-JIT编译器概述","date":"2019-01-04T06:25:33.000Z","updated":"2019-01-04T08:26:22.876Z","comments":true,"path":"2019/01/04/JVM-JIT编译器概述/","link":"","permalink":"http://yoursite.com/2019/01/04/JVM-JIT编译器概述/","excerpt":"","text":"静态编译 vs 动态编译（AOT vs JIT）静态编译 又称 “Ahead-Of-Time”(AOT) 编译 过程：源代码 -&gt; 可执行码 大多数编译工作都在执行之前完成 可以利用复杂而繁重的分析和优化 但是静态信息有时是不够的 而且很难猜出实际的应用程序行为 无法利用特定平台功能，比如：SSE4.2 / AVX / AVX2，TSX，AES-NI，RdRand 动态编译（现代Java虚拟机使用动态编译） 又称 “Just-In-Time”(JIT) 编译 过程：源代码 -&gt; 字节码 -&gt; JIT编译后的可执行码 大多数编译工作都发生在应用程序执行期间 通过收集大量的数据进行Profiling，采用乐观的优化方式 但是资源有限，并且需要与应用程序共享 因此： 启动速度受到影响 并且性能峰值也可能受损（但也不一定） Profiling 在执行期间收集有关代码的数据 不变量 类型，常量（比如空指针） 统计数据 分支，调用 收集到的数据可用于优化期 有根据的猜测 猜测可能是错的 乐观的编译器（Optimistic Compilers） 假设Profile是准确的 根据Profile积极优化，如果发现错了就采取补救措施 并希望他们通常是正确的 Profile引导优化（Profile-guided optimizations (PGO)） 使用Profile更有效的优化，JVM中的PGO： 始终拥有他，默认打开 开发人员（通常）对此不感兴趣或不关心 分析结果始终和执行方案保持一致 乐观的编译器例子123456789public void f() &#123; A a; if (cond /* 始终为true */) &#123; a = new B(); &#125; else &#123; a = new C(); // 从未执行 &#125; a.m(); // A的确切类型是B或C？&#125; 优化：123456789public void f() &#123; A a; if (cond /* 始终为true */) &#123; a = new B(); &#125; else &#123; toInterpreter(); // 切换到解释器 &#125; a.m(); // A的确切类型是B&#125; (J)VM中的动态编译动态编译（JIT） 可以在运行时进行非保守优化 将优化与产品交付周期分离 更新JVM，运行相同的应用程序，实现更高的性能！ 可以”调整“目标平台 需要了解Java程序中的很多内容 加载的类，执行的方法，profile 在此基础上进行优化 如果先前的假设是错误的，可能会重新优化","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"JVM JIT","slug":"JVM-JIT","permalink":"http://yoursite.com/tags/JVM-JIT/"}]}]}